# CVE-2023-24042

Race condition in LightFTP version <2.3. Allows an attacker to circumvent the access controls and read arbitrary files in the file system, as long as the server itself has access to them.

- LightFTP is available at: https://github.com/hfiref0x/LightFTP/
- Last vulnerable commit: 85c6a90fba274f40cd2435fb181c818c9396aaa6
- Vulnerability fixed in: 084baa7caab87ddf376cc713008d5f519e5fa35d

## Vulnerability references:
- GitHub issue: https://github.com/hfiref0x/LightFTP/issues/25
- GitHub advisory: https://github.com/advisories/GHSA-q2vp-hgh9-qp96
- NIST CVE Page: https://nvd.nist.gov/vuln/detail/CVE-2023-24042

## Steps to reproduce

1. Authenticate as an `anonymous` user, or any user which can read at least 1 file on the server
2. Set connection to passive mode using `PASV`
3. Send the `RETR` command with a file name of a file which you are allowed to read
4. Before creating the data connection, send the `USER` command with the absolute filename of a file on the server
5. Create the data connection, and retrieve the file contents

## Demo and exploit

A demonstration environment and an exploit script can be found in the [demo](./demo) directory.

## Explanation
(All the source file references are done as of 85c6a90fba274f40cd2435fb181c818c9396aaa6)

In FTP authentication is usually performed in two steps. First, the client sends the `USER` command along with the username.
The server might then check whether this particular user requires a password check or not. If the username requires a password, a response with code `3xx` will be sent, which means that the `USER` command was succesful, but more information is needed. The additional information (the password) is sent along with the `PASS` command. Only afterwards will the server verify the identity of the client and possibly grant his connection appropriate privileges for further commands.

While it would be ideal if the `PASS` command always immediately followed the `USER` command, some servers (including LightFTP) do not enforce this.
This makes it possible to invoke other commands between these two, or alternatively invoke the `USER` command in the middle of invoking another.
In particular, the second possibility is what this vulnerability is based on.

---

In LightFTP, the primary structure which keeps track of the state of the client connection is `FTPCONTEXT` defined in `Source/ftpserv.h` on line 95.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.h#L95

```c
typedef struct _FTPCONTEXT {
    pthread_mutex_t     MTLock;
    SOCKET              ControlSocket;
    SOCKET              DataSocket;
    pthread_t           WorkerThreadId;
    /*
     * WorkerThreadValid is output of pthread_create
     * therefore zero is VALID indicator and -1 is invalid.
     */
    int                 WorkerThreadValid;
    int                 WorkerThreadAbort;
    in_addr_t           ServerIPv4;
    in_addr_t           ClientIPv4;
    in_addr_t           DataIPv4;
    in_port_t           DataPort;
    int                 File;
    int                 Mode;
    int                 Access;
    int                 SessionID;
    int                 DataProtectionLevel;
    off_t               RestPoint;
    uint64_t            BlockSize;
    char                CurrentDir[PATH_MAX];
    char                RootDir[PATH_MAX];
    char                RnFrom[PATH_MAX];
    char                FileName[2*PATH_MAX];
    gnutls_session_t    TLS_session;
    SESSION_STATS       Stats;
} FTPCONTEXT, *PFTPCONTEXT;
```

For every new client connection, a new thread is created, executing `void *ftp_client_thread(SOCKET s)` which is defined in `Source/ftpserv.c` on line 1725.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L1725

The function allocates the `FTPCONTEXT` structure for the connection state and starts listening for commands from the client.

Each supported command has a mapping from a static string, such as "USER" to a command handler, defined in `Source/ftpserv.c` on line 16.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L16

```c
static const FTPROUTINE_ENTRY ftpprocs[MAX_CMDS] = {
        {"USER", ftpUSER}, {"QUIT", ftpQUIT}, {"NOOP", ftpNOOP}, {"PWD",  ftpPWD },
        {"TYPE", ftpTYPE}, {"PORT", ftpPORT}, {"LIST", ftpLIST}, {"CDUP", ftpCDUP},
        {"CWD",  ftpCWD }, {"RETR", ftpRETR}, {"ABOR", ftpABOR}, {"DELE", ftpDELE},
        {"PASV", ftpPASV}, {"PASS", ftpPASS}, {"REST", ftpREST}, {"SIZE", ftpSIZE},
        {"MKD",  ftpMKD }, {"RMD",  ftpRMD }, {"STOR", ftpSTOR}, {"SYST", ftpSYST},
        {"FEAT", ftpFEAT}, {"APPE", ftpAPPE}, {"RNFR", ftpRNFR}, {"RNTO", ftpRNTO},
        {"OPTS", ftpOPTS}, {"MLSD", ftpMLSD}, {"AUTH", ftpAUTH}, {"PBSZ", ftpPBSZ},
        {"PROT", ftpPROT}, {"EPSV", ftpEPSV}, {"HELP", ftpHELP}, {"SITE", ftpSITE}
};
```

Whenever a new command string is received from the client, the `ftpprocs` array is searched for a string match, and if a match is found the appropriate handler
is executed.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L1804

```c
for (c=0; c<MAX_CMDS; c++) // <-- Iterate over the ftpprocs array
    if (strncasecmp(cmd, ftpprocs[c].Name, cmdlen) == 0) // <-- Compare strings
    {
        cmdno = c;
        rv = ftpprocs[c].Proc(&ctx, params); // <-- Execute the handler function
        break;
    }

if ( cmdno != FTP_PASSCMD_INDEX )
    writelogentry(&ctx, " @@ CMD: ", rcvbuf);
else
    writelogentry(&ctx, " @@ CMD: ", "PASS ***");

if ( cmdno == -1 )
    sendstring(&ctx, error500);
```

Each handler function is of type `int function(PFTPCONTEXT context, const char *params)`. It takes a pointer to the `FTPCONTEXT` and a const pointer to the parameters of the command.
It is then free to modify the `FTPCONTEXT` as it pleases.

In particular, `int ftpUSER(PFTPCONTEXT context, const char *params)` is defined in `Source/ftpserv.c` on line 253.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L253

```c
int ftpUSER(PFTPCONTEXT context, const char *params)
{
    if ( params == NULL )
        return sendstring(context, error501);

    context->Access = FTP_ACCESS_NOT_LOGGED_IN;

    writelogentry(context, " USER: ", (char *)params);
    snprintf(context->FileName, sizeof(context->FileName), "331 User %s OK. Password required\r\n", params);
    sendstring(context, context->FileName);

    /* Save login name to FileName for the next PASS command */
    strcpy(context->FileName, params); // <-- sent username is saved in the FileName field of the FTPCONTEXT structure
    return 1;
}
```

In FTP, the `USER` command should be sent along with the username, so the `params` pointer should point to it. The `strcpy` function copies the username to the `FileName` field of the `FTPCONTEXT` structure. This is probably due to the fact that there is no dedicated `UserName` field. The intended behavior is for the `USER` command to be immediately followed by `PASS`, which would then read the username from the context. However as one might expect, `FileName` is usually used to store/read names of files, and the `ftpUSER` command handler allows us to set it to an arbitrary value whenever we send the `USER` command to the server.

---

A command which might use the `FIleName` field would be the `RETR` command, used to retrieve files from the server. The handler for it is defined in `Source/ftpserv.c` on line 750.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L750

```c
int ftpRETR(PFTPCONTEXT context, const char *params)
{
    struct	stat	filestats;
    pthread_t		tid;

    if (context->Access == FTP_ACCESS_NOT_LOGGED_IN) // <-- Check if user is logged in at all
        return sendstring(context, error530);
    if (context->WorkerThreadValid == 0)
        return sendstring(context, error550_t);
    if ( params == NULL )
        return sendstring(context, error501);

    if ( context->File != -1 ) {
        close(context->File);
        context->File = -1;
    }

    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName); // <-- The path relative to the FTP directory is calculated

    while (stat(context->FileName, &filestats) == 0) // <-- Check if file exists
    {
        if ( S_ISDIR(filestats.st_mode) ) // <-- Check if it is not a directory
            break;

        sendstring(context, interm150);
        writelogentry(context, " RETR: ", (char *)params);
        context->WorkerThreadAbort = 0;

        pthread_mutex_lock(&context->MTLock);

        context->WorkerThreadValid = pthread_create(&tid, NULL, (void * (*)(void *))retr_thread, context); // <-- A separate thread is created to perform the data transmission
        if ( context->WorkerThreadValid == 0 )
            context->WorkerThreadId = tid;
        else
            sendstring(context, error451);

        pthread_mutex_unlock(&context->MTLock);

        return 1;
    }

    return sendstring(context, error550);
}
```

The handler checks whether the user is authenticated at all, but the check should pass for the `anonymous` user. Afterwards, the path relative to the FTP root directory is calculated
and stored in the `FileName` field of the context. The usual checks for the existence of the file and whether it is not a directory are then performed. If everything is okay, a new thread
is created, executing the `retr_thread` function, with context passed as a parameter.

The `retr_thread` function is defined in `Source/ftpserv.c` on line 628.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L628

On line 656 the `retr_thread` creates a data socket using the `create_datasocket` function, with context as a parameter.

```c
clientsocket = create_datasocket(context);
if (clientsocket == INVALID_SOCKET)
    break;
```

 This is due to the fact, that FTP client connection is considered the "control" connection, while all the data transfers are to be made through a separate "data" connection according to the standard.

The `create_datasocket` function is defined in `Source/ftpserv.c` on line 101.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L101

```c
SOCKET create_datasocket(PFTPCONTEXT context)
{
    SOCKET				clientsocket = INVALID_SOCKET;
    struct sockaddr_in	laddr;
    socklen_t			asz;

    memset(&laddr, 0, sizeof(laddr));

    switch ( context->Mode ) { // <-- Check what mode is the connection in, active or passive
    case MODE_NORMAL: // <-- Active mode is uninsteresting
        clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        context->DataSocket = clientsocket;
        if ( clientsocket == INVALID_SOCKET )
            return INVALID_SOCKET;

        laddr.sin_family = AF_INET;
        laddr.sin_port = context->DataPort;
        laddr.sin_addr.s_addr = context->DataIPv4;
        if ( connect(clientsocket, (const struct sockaddr *)&laddr, sizeof(laddr)) == -1 ) { // <-- In active mode, server uses connect
            close(clientsocket);
            return INVALID_SOCKET;
        }
        break;

    case MODE_PASSIVE: // <-- If the connection is in passive mode
        asz = sizeof(laddr);
        clientsocket = accept(context->DataSocket, (struct sockaddr *)&laddr, &asz); // <-- The server waits for the connection from the client
        close(context->DataSocket);
        context->DataSocket = clientsocket;

        if ( clientsocket == INVALID_SOCKET )
            return INVALID_SOCKET;

        context->DataIPv4 = 0;
        context->DataPort = 0;
        context->Mode = MODE_NORMAL;
        break;

    default:
        return INVALID_SOCKET;
    }
    return clientsocket;
}
```

In FTP, the client might be in passive or active mode. In active mode, the client informs server what port should he connect to when creating the data socket. The server
then uses `connect` to "actively" connect to the client. Nowadays, when clients are usually inaccessible from the server, the passive mode is more often used. In passive
mode, the server creates a listening socket instead, and waits for the connection from the client. What is important is that the `create_datasocket` function will block
on the `accept` call until a connection arrives, but only the `retr_thread` worker thread will be blocked. In the meantime, the control connection may accept further commands
and their respective handlers will be performed by the `ftp_client_thread` thread. In addition to that, there is no synchronization between threads when it comes to overwriting
the FTP context. this is where the previosuly explained `ftpUSER` handler comes in, allowing the attacker to overwrite the `FileName` field. All the necessary checks on the file
were already performed prior to creation of the data socket, so once the `create_datasocket` function returns the `retr_thread` will pass the `FileName` field directly to the `open` function
as seen in line 672.

Direct link: https://github.com/hfiref0x/LightFTP/blob/85c6a90fba274f40cd2435fb181c818c9396aaa6/Source/ftpserv.c#L672

```c
f = open(context->FileName, O_RDONLY);
context->File = f;
if (f == -1)
    break;
```

While this vulnerability is a race condition, there is no time limit to perform it, as the server waits for the client to connect to the data port before opening the file.
This makes it relatively consistent and easy to exploit in a single try.


